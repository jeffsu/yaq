// Generated by CoffeeScript 1.6.3
(function() {
  var CHANNELS, EventEmitter, HOSTNAME, Job, NOOP, PID, Queue, WATCH_INTERVAL, async, code, os, redis;

  redis = require('redis');

  EventEmitter = require('events').EventEmitter;

  async = require('async');

  os = require('os');

  code = require('./code');

  Job = require('./job');

  CHANNELS = {
    queued: true,
    completed: true,
    retried: true,
    failed: true,
    timeout: true,
    processing: true
  };

  HOSTNAME = os.hostname();

  PID = process.pid;

  WATCH_INTERVAL = 5000;

  NOOP = function() {};

  Queue = (function() {
    function Queue(name, options) {
      var _this = this;
      this.name = name;
      this.retries = options.retries || 0;
      this.redis = this.createRedis(options);
      this.pubsub = this.createRedis(options);
      this.pubsub.on('message', function(ch, data) {
        return _this.handleMessage(ch, data);
      });
      this.redis.dbug_mode = true;
      this.redis.sadd('yaq:queues', this.name, NOOP);
      this.emitter = new EventEmitter;
      this.listened = {};
      this.toStop = [];
    }

    Queue.prototype.createRedis = function(options) {
      if (options.createRedis) {
        return options.createRedis();
      } else {
        return redis.createClient();
      }
    };

    Queue.prototype.watchProcess = function(jobFn) {
      var fn, i, n, running, test, _i,
        _this = this;
      if (arguments[1]) {
        n = arguments[0];
        jobFn = arguments[1];
      } else {
        n = 1;
      }
      running = true;
      test = function() {
        return running;
      };
      fn = function(next) {
        return _this.process(function(err, job) {
          if (job) {
            job.once('finish', next);
            return jobFn(job);
          } else {
            return setTimeout(next, WATCH_INTERVAL);
          }
        });
      };
      for (i = _i = 1; 1 <= n ? _i <= n : _i >= n; i = 1 <= n ? ++_i : --_i) {
        async.whilst(fn, test, NOOP);
      }
      return this.toStop.push(function() {
        return running = false;
      });
    };

    Queue.prototype.stop = function() {
      var fn, _i, _len, _ref, _results;
      _ref = this.toStop;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        fn = _ref[_i];
        _results.push(fn());
      }
      return _results;
    };

    Queue.prototype.counts = function(cb) {
      var m;
      m = this.redis.multi();
      m.zcard(this.name + ':queued');
      m.zcard(this.name + ':processing');
      m.zcard(this.name + ':failed');
      m.zcard(this.name + ':completed');
      return m.exec(function(err, results) {
        if (err) {
          return cb(err);
        }
        return cb(err, {
          queued: results[0],
          processing: results[1],
          failed: results[2],
          completed: results[3]
        });
      });
    };

    Queue.prototype.clean = function(cb) {
      if (cb == null) {
        cb = NOOP;
      }
      return this.redis["eval"](code.clean, 2, this.name, Date.now(), cb);
    };

    Queue.prototype.clear = function(cb) {
      if (cb == null) {
        cb = NOOP;
      }
      return this.redis["eval"](code.clear, 1, this.name, cb);
    };

    Queue.prototype.push = function(options, cb) {
      var job;
      if (cb == null) {
        cb = NOOP;
      }
      job = new Job(this, options);
      return this.redis["eval"](code.push, 2, this.name, job.toJSON(), function(err, res) {
        if (err) {
          return cb(err);
        }
        return cb(err, res ? job : false);
      });
    };

    Queue.prototype.process = function(cb) {
      var _this = this;
      if (cb == null) {
        cb = NOOP;
      }
      return this.redis["eval"](code.process, 4, this.name, HOSTNAME, PID, Date.now(), function(err, id) {
        if (err) {
          return cb(err);
        }
        if (id) {
          return _this.find(id, cb);
        } else {
          return cb(null, null);
        }
      });
    };

    Queue.prototype.find = function(id, cb) {
      return Job.find(this, id, cb);
    };

    Queue.prototype.handleMessage = function(channel, data) {
      var m;
      console.log(channel, data);
      if (m = channel.match(/^([^:]+):(.*)$/)) {
        return this.emit(m[2], data);
      }
    };

    Queue.prototype.on = function() {
      var message;
      message = arguments[0];
      this.emitter.on.apply(this.emitter, arguments);
      if (CHANNELS[message] && !this.listened[message]) {
        this.listened[message] = true;
        return this.pubsub.subscribe("" + this.name + ":" + message);
      }
    };

    Queue.prototype.emit = function() {
      return this.emitter.emit.apply(this.emitter, arguments);
    };

    return Queue;

  })();

  module.exports = Queue;

}).call(this);
